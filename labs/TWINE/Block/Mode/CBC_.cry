/* *
 * Cipher Block Chaining Mode
 * adapted from `labs::TWINE::Block::Mode::CBC` in
 * `https://github.com/GaloisInc/cryptol-specs`
 */
module labs::TWINE::Block::Mode::CBC_ where

import `labs::TWINE::Block_ as BlockCipher_

parameter
    // labs::TWINE::Block parameters

    /** symmetric en/decryption key */
    type _BlockCipher_Key: *
    /** unit of text applied to block cipher */
    type _BlockCipher_Block: *
    /** needed to prove decryption recovers encrypted block(s) */
    type constraint Cmp _BlockCipher_Block

    /** encrypt a block */
    _BlockCipher_encrypt: BlockCipher_Op
    /** decrypt a block */
    _BlockCipher_decrypt: BlockCipher_Op


    // CBC parameters

    /** blocks must be XOR-able */
    type constraint Logic _BlockCipher_Block


/** symmetric en/decryption key */
type Key = _BlockCipher_Key

/** unit of text applied to block cipher */
type Block = _BlockCipher_Block

/** block en/decrypt signature */
type BlockCipher_Op = BlockCipher_::Op Key Block

/** encrypt a block */
BlockCipher_encrypt: BlockCipher_Op
BlockCipher_encrypt = _BlockCipher_encrypt

/** decrypt a block */
BlockCipher_decrypt: BlockCipher_Op
BlockCipher_decrypt = _BlockCipher_decrypt

/** Decryption with same key recovers encrypted block. */
BlockCipher_recovery: Key -> Block -> Bit
property BlockCipher_recovery k t = 
    BlockCipher_decrypt k (BlockCipher_encrypt k t) == t

/** Decryption with same key recovers encrypted block. */
BlockCipher_injective: Key -> Block -> Block -> Bit
property BlockCipher_injective k t1 t2 = 
    t1 != t2 ==> BlockCipher_encrypt k t1 != BlockCipher_encrypt k t2


/** multi-block en/decrypt signature */
type Op n = Key -> Block -> [n]Block -> [n]Block


/** encrypt multiple blocks */
encrypt: {n} Op n
encrypt k iv ps = cs
  where
    cs = [ BlockCipher_encrypt k (p ^ c')
         | p <- ps
         | c' <- [iv] # cs ]

/** decrypt multiple blocks */
decrypt: {n} Op n
decrypt k iv cs = 
    [ (BlockCipher_decrypt k c) ^ c'
    | c <- cs
    | c' <- [iv] # cs ]


/** Decryption with same key and IV recovers encrypted blocks. */
recovery : {n} (fin n) => Key -> Block -> [n]Block -> Bit
recovery k iv t = 
    decrypt k iv (encrypt k iv t) == t

/** The same key and IV encrypt different plaintext as different ciphertext. */
injectivity : {n} (fin n) => Key -> Block -> [n]Block -> [n]Block -> Bit
injectivity k iv t1 t2 = 
    t1 != t2 ==> encrypt k iv t1 != encrypt k iv t2
